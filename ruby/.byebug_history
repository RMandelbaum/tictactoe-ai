exit
board
@game
game
exit
@game
n
@computer
@player2
@player1
@game
n
@player2
@player1
n
exit
n
exit
n
space
board.spaces[space]
board.spaces
n
exit
game.board.spaces
game.board
game
possible_game
exit
game.board.spaces
game.board
game
exit
game
n
possible_game
n
game
exit
game.game_over?
game
n
possible_game
n
game
exit
game.game_over?
game
game.game_over?
n
game.game_over?
exit
game.game_over?
n
available_spaces
n
scores
n
scores
n
game.game_over?
game
n
game.play(move)
game.play
game.play(2)
move
possible_game
n
available_spaces
calculate_best_move(game, depth = 1, {})
n
calculate_best_move(game, depth += 1, {})
space
exit
n
best_score[space]
best_score
n
best_score
n
space
n
@computer1
@player2
@player1
n
@player2
@player1
n
@computer1
@player2
@player1
n
@board
@opponent
@current_player
exit
n
space
game.play(space)
n
space
game.play(space)
exit
n
rows
n
exit
n
rows
n
rows
exit
n
@turns_remaining
n
rows
n
@current_player
n
@current_player
n
@player2
@player1
@current_player
n
@player2
@player1
n
@current_player
n
@opponent
@current_player
n
@current_player
n
@computer1
@player2
@player1
n
exit
wxit
rows
n
check_spaces
n
rows
n
best_score
n
game.play(space)
n
check_spaces
n
check_spaces
n
@turns_remaining
n
patterns
n
rows
n
board.spaces.each_slice(board.board_size).to_a
n
m
@computer.play(game)
@computer,play(game)
n
rows
wos
n
rows
exit
@game
game
@computer1
@computer
@computer.play(@game)
game.board
board
n
@turns_remaining
n
set_winner(winner)
winner
n
winner
n
patterns
n
patterns
n
exit
board.spaces.each_slice(3).to_a
board.spaces.each_slice(3)
board.board_size
board
exit
n
rows
exit
nexit
n
nn
n
get_winner(patterns)
patterns
winner
n
rows
n
rows
exit
get_rows
rows
n
rows
exit
board.spaces.each_slice(board.board_size).to_a
get_rows
exit
get_rows
board
rows
n
exit
board.spaces.each_slice(board.board_size).to_a.flatten
eval(board.spaces.each_slice(board.board_size).to_a).flatten
eval(board.spaces.each_slice(board.board_size).to_a)
board.spaces.each_slice(board.board_size).to_a
board
n
check_spaces.each { |s| game.play(s) }
game.play(space)
check_spaces.each do |space| 
check_spaces
n
game.board.spaces.select {|space| space.is_a?(Integer) }
n
game.game_over?
game
calculate_best_move(game)
game
exit
2
exit
nn
n
index
exit
wzit
n
best_score[space]
n
best_score[space]
