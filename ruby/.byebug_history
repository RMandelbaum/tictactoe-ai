calculate_best_move(game, depth += 1, {})
best_score[space]
n
best_score[space]
space
n
index
n
@current_player
change_turns
@current_player
exit
@opponent
@current_player
exit
n
game
check_spaces
n
winner
n
@computer1
@player2
@player1
@current_player
n
return winner !=''
get_winner(patterns)
patterns
winner
exit
@game.game_over?
n
winner
n
winner
n
patterns
winner
n
winning_pattern[0]
patterns.each.select { |pattern| pattern.uniq.length == 1 }
patterns.select { |pattern| pattern.uniq.length == 1 }
patterns.select { |pattern| pattern.length == 1 }
patterns
winning_pattern
exit
game.play(space)
check_spaces
exit
board
@game
game
exit
@game
n
@computer
@player2
@player1
@game
n
@player2
@player1
n
exit
n
exit
n
space
board.spaces[space]
board.spaces
n
exit
game.board.spaces
game.board
game
possible_game
exit
game.board.spaces
game.board
game
exit
game
n
possible_game
n
game
exit
game.game_over?
game
n
possible_game
n
game
exit
game.game_over?
game
game.game_over?
n
game.game_over?
exit
game.game_over?
n
available_spaces
n
scores
n
scores
n
game.game_over?
game
n
game.play(move)
game.play
game.play(2)
move
possible_game
n
available_spaces
calculate_best_move(game, depth = 1, {})
n
calculate_best_move(game, depth += 1, {})
space
exit
n
best_score[space]
best_score
n
best_score
n
space
n
@computer1
@player2
@player1
n
@player2
@player1
n
@computer1
@player2
@player1
n
@board
@opponent
@current_player
exit
n
space
game.play(space)
n
space
game.play(space)
exit
n
rows
n
exit
n
rows
n
rows
exit
n
@turns_remaining
n
rows
n
@current_player
n
@current_player
n
@player2
@player1
@current_player
n
@player2
@player1
n
@current_player
n
@opponent
@current_player
n
@current_player
n
@computer1
@player2
@player1
n
exit
wxit
rows
n
check_spaces
n
rows
n
best_score
n
game.play(space)
n
check_spaces
n
check_spaces
n
@turns_remaining
n
patterns
n
rows
n
board.spaces.each_slice(board.board_size).to_a
n
m
@computer.play(game)
@computer,play(game)
n
rows
wos
n
rows
exit
@game
game
@computer1
@computer
@computer.play(@game)
game.board
board
n
@turns_remaining
n
set_winner(winner)
winner
n
winner
n
patterns
n
patterns
n
exit
board.spaces.each_slice(3).to_a
board.spaces.each_slice(3)
board.board_size
board
exit
n
rows
exit
nexit
n
nn
n
get_winner(patterns)
