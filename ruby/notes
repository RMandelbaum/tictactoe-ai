Game Play

The UI was well done and handled my various attempts to break it without issue.
I liked Bob!
Bob! was pretty good, but he liked toying with his opponent and didn’t always win when he could. You can reproduce this with the following combo: 1,3,5 (Bob will choose 1 instead of 2 for the win)

 **minimax figure out a better recursion method?? or Negamax

Board

This was a nice class overall, with short, expressive and easy to follow methods
The board was hard coded to be a fixed size (seems like a lot would have to change if we added the requirement for a variable sized board)

**have user prompt build a dynamic board
** board builder class

Computer

A nice first attempt at the implementation of the Negamax algorithm, needs some tweaking as shown by the gameplay, but well-structured and easy to follow.

Game

This seems to be a bit of an early abstraction. For the most part it seems like Board could be invoked directly without much drawback. It’s function as a collaborator seems slightly forced (Does that make sense?)

** Separate win conditions into a separate class
** Game calls board and not so necessary for a lot of the methods
** redundant

Player Input

This class is highly coupled to a CLI implementation of the game. What would happen if we changed the requirement such that we could use the same business logic to be run for both a CLI and Browser based UI?

** to decouple the language to place all the puts in one folder in players_input and players_output or one class


Player

There seems to be a cyclic dependency here in that the game knows about the player and player also knows about the game. Can you think of why that might not be the best thing?

**board doesn't need to know about players at all


TicTacToe

Again this class is highly coupled to a CLI implementation.
It seems to be doing several things including running the game loop and setting up the game. I think there’s a potential missing abstraction here
** separation of concern

Tests

Nice job with these! The only things missing are the tougher things to test, such as UI, the Negamax algorithm and the game-loop itself.


Next Steps/Requirements

The ability to play an unbeatable computer on a 3x3 and 4x4 board (should be fast enough to play on 4x4 as well)

** use an algorithm to mathmatically figure out a win loop to print upon what the user chooses

** separation of concern for each class -- good at one thing of each thing
** design principle separation of concern

A truly ruthless opponent that seizes every opportunity to win.

Do as much as you can to decouple the game logic from the UI. Please be sure to add tests as well. It might be helpful to think of the game logic as a gem. How can you make it so that any given UI easily consumes this code. (Bonus if you actually make it a gem :) )
